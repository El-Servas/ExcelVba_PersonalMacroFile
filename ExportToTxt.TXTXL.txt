Representación Textual del archivo de Excel: "ExportToTxt.xls"

Resumen
=======

 * Hojas: 1

 * Nombres Definidos: 0

 * Módulos de Visual Basic: 5

 * Líneas de código VB: 494

Detalle
=======

Hojas:
 [Sheet1]

Contenido:
[Sheet1]

Nombres:

Nombre del proyecto VB: [Lib_ExportToTxt]

Módulos VBA:
 [ThisWorkbook] Tipo: 100
 [Sheet1] Tipo: 100
 [Lib] Tipo: 1
 [ExportToTxtClass] Tipo: 2
 [Plantillas] Tipo: 1

Codigo:
[ThisWorkbook] 12 líneas de código.
///--- BEGINNING OF MODULE ---
Option Explicit

Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)

    'En caso de que se grabe éste libro, que es el que tiene el código, vamos a llamar directamente a la rutina:
    Lib.Main Me

    'Para los demás libros, se debe de mandar llamar la rutina que dispare el proceso:
    'On Error Resume Next: Application.Run "Personal.xlsb!ExportToTxt.ExportToTxt", Me

End Sub

\\\--- END OF MODULE ---

[Sheet1] 0 líneas de código.
///--- BEGINNING OF MODULE ---
\\\--- END OF MODULE ---

[Lib] 463 líneas de código.
///--- BEGINNING OF MODULE ---
Option Explicit
'---------------------------------------------------------------------------------------
' Module    : ExportToTxt
' Author    : +
' Date      : 05/06/2013
' Purpose   : Exporta una representación textual de un libro de Excel
'---------------------------------------------------------------------------------------
Private Const VERSION As String = "v2.9 - 2013-06-14"
'---------------------------------------------------------------------------------------
Private Const LIB_NAME As String = "Lib_ExportToTxt"
Private Const LIB_FRIENDLY_NAME As String = "Exportación a Texto"

Private Const TOKEN_PRE_EXTENSION = ".TXTXL"
Private Const TOKEN_EXTENSION = ".txt"

Private Const TOKEN_HEADER = "Representación Textual del archivo de Excel: "
Private Const TOKEN_SEPARATOR As String = "----------------------------------------------------------------------------------------------------"
Private Const TOKEN_HOJAS_TITLE = "Hojas:"
Private Const TOKEN_CONTENT_TITLE = "Contenido:"
Private Const TOKEN_NOMBRES_TITLE = "Nombres:"
Private Const TOKEN_VBPROJECT_PROTECTED As String = "El proyecto VB está protegido y no hay acceso a los módulos."
Private Const TOKEN_MODULOS_TITLE = "Módulos VBA:"
Private Const TOKEN_CODIGO_TITLE = "Codigo:"
Private Const TOKEN_MODULE_BEGINS = "///--- BEGINNING OF MODULE ---"
Private Const TOKEN_MODULE_END = "\\\--- END OF MODULE ---"
Private Const SHEET_TITLE_CELL_LISTING_THRESHOLD = 25 'El número de celdas entre la etiqueta de la hoja en el listado de celdas

Private Const TOKEN_MESSAGEBOX_TITLE As String = LIB_FRIENDLY_NAME
Private Const ERROR_1 As String = "Proceso cancelado manualmente."

Private FSO As New Scripting.FileSystemObject
Private Stream As TextStream 'El stream donde vamos a escribir el archivo
Private flVisual As Boolean 'Bandera que define si la ejecución es con confirmación visual.

Private BTE As Workbook '(BookToExport) Referencia al libro que vamos a exportar.
Private VBProjectIsProtected As Boolean
Private StartTime As Date _
        , EllapsedMinutes As String 'Para cronometrar el proceso.

Private ErrNum, ErrDesc 'Auxiliares para mantener los detalles del error si ocurre durante la ejecución de un delegado.

Sub Main(bookToExport As Workbook, Optional visual As Boolean = False)
On Error GoTo Catch
    Set BTE = bookToExport
    flVisual = visual
    PreFlight
   
    If flVisual Then If Not ConfirmarEjecucion Then Err.Raise vbObjectError + 1, , ERROR_1

    Set Stream = FSO.CreateTextFile(GetTXTFileName(), True, False)
    SaveSettings
    StartTime = Date + Time
    
    GenResumen
    
    GenHojas
    GenNombres
    GenModulos
    
    MensajeFinal
    
    If flVisual Then Call MsgBox("Proceso terminado en " & EllapsedMinutes & " minutos.", vbInformation Or vbDefaultButton1, TOKEN_MESSAGEBOX_TITLE)
Catch:
    If Err.Number <> 0 Then
        Dim MensajeDeError As String
        MensajeDeError = "Ocurrió un error al correr el proceso de exportación:" & vbCrLf & vbCrLf _
            & Err.Number & " " & Err.Description
        MsgBox MensajeDeError, vbCritical, TOKEN_MESSAGEBOX_TITLE
        If Not StreamClosed() Then Log MensajeDeError
    End If
    
    RestoreSettings
    If Not Stream Is Nothing Then Stream.Close
End Sub

Sub PreFlight()
    VBProjectIsProtected = BTE.VBProject.Protection = vbext_pp_locked
End Sub

Function GetTXTFileName() As String
    Dim NombreDelArchivo As String _
    , Ruta As String _
    , NombreCompleto As String
    
    NombreDelArchivo = FSO.GetBaseName(BTE.name) & TOKEN_PRE_EXTENSION & TOKEN_EXTENSION
    Ruta = BTE.Path
    NombreCompleto = FSO.BuildPath(Ruta, NombreDelArchivo)
    
    GetTXTFileName = NombreCompleto
End Function

'----------------------------------------------------------------------------------------------------
'Purpose: 'Despliega la confirmación visual inicial y regresa si se continúa o se cancela el proceso.
'----------------------------------------------------------------------------------------------------
Function ConfirmarEjecucion() As Boolean
    'Preparamos el mensaje, aprovechando que ya se hizo el PreFlight.
    Dim MensajeConfirmacion As String
    'Intro del mensaje con el nombre del archivo a exportar.
    MensajeConfirmacion = "Inicio del proceso de exportación a texto del archivo:" & vbCrLf _
        & BTE.name & vbCrLf & vbCrLf _
        & "Dependiento del tamaño y complejidad del libro, puede tardar algunos minutos." & vbCrLf & vbCrLf
    
    MensajeConfirmacion = MensajeConfirmacion & "Verificación previa:" & vbCrLf
    'Estado de la protección del proyecto VB.
    If VBProjectIsProtected Then
        MensajeConfirmacion = MensajeConfirmacion & "* " & UCase(TOKEN_VBPROJECT_PROTECTED) & vbCrLf & vbCrLf
    Else
        MensajeConfirmacion = MensajeConfirmacion & "* " & "El proyecto de Visual Basic es accesible." & vbCrLf & vbCrLf
    End If
    
    'Pie del mensaje con el número de la versión.
    MensajeConfirmacion = MensajeConfirmacion & GenVersionString()
                   
    Select Case MsgBox(MensajeConfirmacion, vbOKCancel Or vbInformation Or vbDefaultButton1, TOKEN_MESSAGEBOX_TITLE)
    Case vbOK
        ConfirmarEjecucion = True
    End Select
End Function

'----------------------------------------------------------------------------------------------------
'Purpose: Construye un string que va a identificar la librería, el archivo que la contiene y la versión.
'----------------------------------------------------------------------------------------------------
Function GenVersionString() As String
    GenVersionString = LIB_NAME & " [" & ThisWorkbook.name & "] " & VERSION
End Function

'====================================================================================================
'RESUMEN
'====================================================================================================

Sub GenResumen()
    ' - Nombre del archivo
    GenEncabezado
    
    Log "Resumen" & vbCrLf & "======="
    Log
    
    Dim NumeroHojas As Integer: NumeroHojas = GetNumHojas
    Log " * Hojas: " & NumeroHojas
    Log
    
    Dim NumeroNombresDefinidos As Integer: NumeroNombresDefinidos = GetNumNombres
    Log " * Nombres Definidos: " & NumeroNombresDefinidos
    Log
    
    If Not VBProjectIsProtected Then
        Dim NumeroModulosVB As Integer: NumeroModulosVB = GetNumModulosVB
        Log " * Módulos de Visual Basic: " & NumeroModulosVB
        Log
        
        Dim NumeroLineasCodigo As Integer: NumeroLineasCodigo = GetNumLineas
        Log " * Líneas de código VB: " & NumeroLineasCodigo
    Else
        Log TOKEN_VBPROJECT_PROTECTED
    End If
    Log
    
    Log "Detalle" & vbCrLf & "======="
    Log
End Sub

Sub GenEncabezado()
    Log TOKEN_HEADER & """" & BTE.name & """"
    If flVisual Then Log "Fecha y hora de generación: " & Date + Time
    Log
End Sub

Function GetNumHojas() As Integer
    GetNumHojas = BTE.Worksheets.Count
End Function

Function GetNumNombres() As Integer
    GetNumNombres = BTE.Names.Count
End Function

Function GetNumModulosVB() As Integer
    GetNumModulosVB = BTE.VBProject.VBComponents.Count
End Function

Function GetNumLineas() As Integer
    'Iteramos los componentes para contar las líneas.
    Dim NumLineas As Integer
    Dim vbc As vbcomponent
    For Each vbc In BTE.VBProject.VBComponents
        NumLineas = NumLineas + vbc.CodeModule.CountOfLines
    Next
    GetNumLineas = NumLineas
End Function

'====================================================================================================

Sub GenHojas()
    '--- Lista de hojas
    Log TOKEN_HOJAS_TITLE
    IteraHojas "ImprimeNombreDeHoja"
    Log
    
    '--- Contenido de cada hoja
    Log TOKEN_CONTENT_TITLE
    IteraHojas "ProcesaContenidoDeHoja"
End Sub

Sub GenNombres()
    Log TOKEN_NOMBRES_TITLE
    IteraNombres "ImprimeNombre"
    Log
End Sub

Sub GenModulos()
    Log "Nombre del proyecto VB: [" & BTE.VBProject.name & "]"
    Log
    
    'Antes de intentar acceder a los módulos, verificamos que el proyecto no esté protegido:
    If Not VBProjectIsProtected Then
        Log TOKEN_MODULOS_TITLE
        IteraModulos "ImprimeNombreDeModulo"
        Log
        
        Log TOKEN_CODIGO_TITLE
        IteraModulos "ProcesaModulo"
    Else
        Log TOKEN_VBPROJECT_PROTECTED
    End If
    Log
End Sub

'MODULOS VB
'====================================================================================================

'Delegate
Sub ProcesaModulo(vbcomp As vbcomponent, iterationIndex As Integer)
On Error GoTo DelegateError
    Dim CodeLines As Integer
    CodeLines = vbcomp.CodeModule.CountOfLines
    Log "[" & vbcomp.name & "] " & CodeLines & " líneas de código."
    
    Log TOKEN_MODULE_BEGINS
    If CodeLines > 0 Then
        Log vbcomp.CodeModule.Lines(1, CodeLines)
    End If
    Log TOKEN_MODULE_END
    
    Log
DelegateError:
    ErrNum = Err.Number: ErrDesc = Err.Description
End Sub

'Delegate
Sub ImprimeNombreDeModulo(vbcomp As vbcomponent, iterationIndex As Integer)
On Error GoTo DelegateError
    Log " [" & vbcomp.name & "] Tipo: " & vbcomp.Type
DelegateError:
    ErrNum = Err.Number: ErrDesc = Err.Description
End Sub

'Delegate caller
Sub IteraModulos(DelegateName As String)
    Dim vbcomponent As vbcomponent
    Dim ix As Integer
    ix = 0
    On Error GoTo ErrorAccesandoVBProject
    For Each vbcomponent In BTE.VBProject.VBComponents
        ix = ix + 1
        ErrNum = 0: Application.Run DelegateName, vbcomponent, ix
        If ErrNum <> 0 Then Err.Raise ErrNum, , ErrDesc
    Next
ErrorAccesandoVBProject: 'Si truena no hacemos nada.
    Exit Sub
End Sub

'RANGOS NOMBRADOS
'====================================================================================================

'Delegate
Sub ImprimeNombre(name As name, iterationIndex As Integer)
On Error GoTo DelegateError
    Log " [" & name.name & "] " & name.RefersTo
DelegateError:
    ErrNum = Err.Number: ErrDesc = Err.Description
End Sub

'Delegate caller
Sub IteraNombres(DelegateName As String)
    Dim name As name
    Dim ix As Integer
    ix = 0
    For Each name In BTE.Names
        ix = ix + 1
        ErrNum = 0: Application.Run DelegateName, name, ix
        If ErrNum <> 0 Then Err.Raise ErrNum, , ErrDesc
    Next
End Sub

'HOJAS
'====================================================================================================

'Delegate
Sub ImprimeNombreDeHoja(sheet As Worksheet, iterationIndex As Integer)
On Error GoTo DelegateError
    Dim Mensaje As String
    If Not sheet.Visible Then Mensaje = Mensaje & " - Escondida"
    If sheet.ProtectContents Then Mensaje = Mensaje & " - Protegida"
    Log " [" & sheet.name & "]" & Mensaje
DelegateError:
    ErrNum = Err.Number: ErrDesc = Err.Description
End Sub

'Delegate
Sub ProcesaContenidoDeHoja(sheet As Worksheet, iterationIndex As Integer)
On Error GoTo DelegateError

    Application.StatusBar = "Exportando hoja " & iterationIndex & " de " & sheet.Parent.Worksheets.Count & " - [" & sheet.name & "]"

    'Determinamos si la hoja está protegida y hay que desprotegerla.
    Dim Mensaje As String
    Dim BkHojaProtegida As Boolean
    If sheet.ProtectContents Then
        BkHojaProtegida = True
        Mensaje = Mensaje & " - Hoja Protegida"
        
        'La intentamos desproteger
        On Error Resume Next: sheet.Unprotect " "
        
        If Not sheet.ProtectContents Then
            Mensaje = Mensaje & " - Se desprotegió sin contraseña."
        Else
            Mensaje = Mensaje & " - NO SE DESPROTEGIÓ."
        End If
    End If
    
    'Procesamos las celdas.
    Log "[" & sheet.name & "]" & Mensaje
    IteraCeldas sheet, "ProcesaCelda"
    Log
    
    'Reprotegemos si es necesario
    If BkHojaProtegida Then sheet.Protect
    
    Application.StatusBar = False
DelegateError:
    ErrNum = Err.Number: ErrDesc = Err.Description
End Sub

'Delegate caller
Sub IteraHojas(DelegateName As String)
    Dim sheet As Worksheet
    Dim ix As Integer
    ix = 0
    For Each sheet In BTE.Worksheets
        ix = ix + 1
        ErrNum = 0: Application.Run DelegateName, sheet, ix
        If ErrNum <> 0 Then Err.Raise ErrNum, , ErrDesc
    Next
End Sub

'CELDAS
'====================================================================================================

'Delegate
Function ProcesaCelda(cell As Range, iterationIndex As Integer) As Integer
On Error GoTo DelegateError
    ProcesaCelda = iterationIndex 'Inmediatamente establecemos el valor
    
    Dim Direccion As String
    Dim Contenido As String
    Dim NombreDefinido As String
    Dim CeldaSeProcesa As Boolean
    
    If cell.FormulaHidden And cell.Parent.ProtectContents Then 'Fórmula escondida y la hoja está protegida.
        CeldaSeProcesa = True
        Contenido = "**FÓRMULA INACCESIBLE**"
    ElseIf cell.Formula <> "" Then 'Fórmula accesible, pero que no esté vacía.
        CeldaSeProcesa = True
        Contenido = cell.Formula
    End If
    
    If CeldaSeProcesa Then
        'Insertamos el nombre de la hoja cada N celdas
        If iterationIndex Mod SHEET_TITLE_CELL_LISTING_THRESHOLD = 0 And iterationIndex <> 0 Then
            Log "[" & cell.Parent.name & "]"
        End If
        Direccion = cell.Address(False, False): Direccion = "[" & Direccion & "] "
        NombreDefinido = GetNameOfCell(cell): If NombreDefinido <> "" Then NombreDefinido = "(" & NombreDefinido & ") "
        Contenido = "\" & Contenido & "\"
        Log Direccion & NombreDefinido & Contenido
        ProcesaCelda = iterationIndex + 1
    End If
DelegateError:
    ErrNum = Err.Number: ErrDesc = Err.Description
End Function

'Delegate caller
Sub IteraCeldas(sheet As Worksheet, DelegateName As String)
    Dim cell As Range, column As Range
    Dim ix As Integer
    ix = 0
    For Each column In sheet.UsedRange.Cells.Columns
        For Each cell In column.Cells
            ErrNum = 0: ix = Application.Run(DelegateName, cell, ix)
            If ErrNum <> 0 Then Err.Raise ErrNum, , ErrDesc
        Next
        DoEvents
    Next
End Sub

Function GetNameOfCell(cell As Range) As String
    On Error GoTo NoName
    GetNameOfCell = cell.name.name
Exit Function
NoName:
    GetNameOfCell = ""
End Function

'====================================================================================================

Sub Log(Optional Mensaje As String)
    'Debug.Print Mensaje
    Stream.WriteLine (Mensaje)
End Sub

'----------------------------------------------------------------------------------------------------
'Purpose: Regresa verdadero si al intentar accesar el Stream, marca error. (Se asume que está cerrada)
'----------------------------------------------------------------------------------------------------
Function StreamClosed() As Boolean
    On Error GoTo IsClosed
    StreamClosed = Stream.AtEndOfLine
    StreamClosed = False 'No marcó error, el Stream no está cerrado.
    Exit Function
IsClosed:
    StreamClosed = True
End Function

Sub SaveSettings()
    On Error Resume Next: Application.Calculation = xlCalculationManual: On Error GoTo 0
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    'Application.Interactive = False
End Sub

Sub RestoreSettings()
    On Error Resume Next: Application.Calculation = xlCalculationAutomatic: On Error GoTo 0
    Application.Interactive = True
    Application.ScreenUpdating = True
    Application.EnableEvents = True
End Sub

'----------------------------------------------------------------------------------------------------
'Purpose: Construye y loguea el mensaje final. Incluye la duración del proceso si fue visual.
'----------------------------------------------------------------------------------------------------
Sub MensajeFinal()
    Dim MensajeFinal As String
    
    'Calculamos el tiempo empleado
    EllapsedMinutes = FormatNumber(DateDiff("s", StartTime, Date + Time) / 60, 2)
    
    'Construimos el mensaje.
    MensajeFinal = "** Fin del proceso de exportación."
    If flVisual Then MensajeFinal = MensajeFinal & " Proceso realizado en " & EllapsedMinutes & " minutos."
    MensajeFinal = MensajeFinal & " **"
    
    Log MensajeFinal
    Log GenVersionString()
End Sub
\\\--- END OF MODULE ---

[ExportToTxtClass] 2 líneas de código.
///--- BEGINNING OF MODULE ---
Option Explicit

\\\--- END OF MODULE ---

[Plantillas] 17 líneas de código.
///--- BEGINNING OF MODULE ---
Option Explicit

Public ErrNum, ErrDesc 'Para que compile el proyecto.

Sub PlantillaParaDelegado()
On Error GoTo DelegateError
    'Código aquí.
    'Si el delegado regresa valor, es buena idea asignarlo de inmediato, si se tiene un valor default.
DelegateError:
    ErrNum = Err.Number: ErrDesc = Err.Description 'ErrNum y ErrDesc deben de estar definidas a nivel módulo.
End Sub

Sub PlantillaParaLlamarADelegado()
    'ErrNum y ErrDesc deben de estar definidas y accesibles en el módulo donde esté el delegado (Si fuera otro)
    ErrNum = 0: Application.Run "NombreDelDelegado" ',Más, parámetros, etc
    If ErrNum <> 0 Then Err.Raise ErrNum, , ErrDesc
End Sub
\\\--- END OF MODULE ---


** Fin del proceso de exportación. **
Lib_ExportToTxt [ExportToTxt.xls] v2.9 - 2013-06-14
