Representación Textual del archivo de Excel: "PersonalDev.XLSB"

Resumen
=======

 * Hojas: 1

 * Nombres Definidos: 0

 * Módulos de Visual Basic: 16

 * Líneas de código VB: 1087

Detalle
=======

Hojas:
 [Sheet1]

Contenido:
[Sheet1]

Nombres:

Nombre del proyecto VB: [VBA_PERSONAL]

Módulos VBA:
 [Interactive] Tipo: 1
 [ThisWorkbook] Tipo: 100
 [Sheet1] Tipo: 100
 [Utils] Tipo: 1
 [UI] Tipo: 1
 [foWBChooser] Tipo: 3
 [VC_COT] Tipo: 1
 [foOptionChooser] Tipo: 3
 [RemoveInternalPasswords] Tipo: 1
 [ReplaceByRange] Tipo: 1
 [MyLibs] Tipo: 1
 [BookLoaderClass] Tipo: 2
 [Config] Tipo: 1
 [UtilsClass] Tipo: 2
 [RunHelperClass] Tipo: 2
 [LoggerClass] Tipo: 2

Codigo:
[Interactive] 122 líneas de código.
///--- BEGINNING OF MODULE ---
'==================================================================================
' Módulo para funciones que ayuden a trabajar en la hoja en vivo.
'==================================================================================

Sub AutoFitSelection()
    Selection.Columns.AutoFit
End Sub

Sub Titularizar_Celdas()
    If Not AssertActiveWindow() Then
        Exit Sub    'Nada que hacer.
    End If
    
Dim Rango As Range 'Nos ayuda en el IntelliSense
Dim celda As Range

Set Rango = Selection.Cells

Rango.HorizontalAlignment = xlHAlignCenter
Rango.Font.Bold = True
Rango.Font.ColorIndex = xlAutomatic
Rango.Interior.ColorIndex = 35
'Rango.WrapText = False

For Each celda In Rango
    celda.BorderAround (xlSolid)
Next

Rango.CurrentRegion.Columns.AutoFit

Set celda = Nothing
Set Rango = Nothing
End Sub

Sub ConfigurarPagina(Optional InPagesWide, Optional InPagesTall, Optional InPageOrientation)
    If Not AssertActiveWindow() Then
        Exit Sub    'Nada que hacer.
    End If
    
    'Defaults
    If IsMissing(InPagesWide) Then InPagesWide = 1
    If IsMissing(InPagesTall) Then InPagesTall = 1
    If IsMissing(InPageOrientation) Then InPageOrientation = xlPortrait
    
    lbBKVisible = Application.Visible
    lbBKInteractive = Application.INTERACTIVE
    lbScreenUpdating = Application.ScreenUpdating
    
    Application.INTERACTIVE = False
    Application.ScreenUpdating = False
    'Application.Visible = False
    With ActiveSheet.PageSetup
        .PrintTitleRows = ""
        .PrintTitleColumns = ""
    End With
    'ActiveSheet.PageSetup.PrintArea = ""
    With ActiveSheet.PageSetup
        '.LeftHeader = ""
        '.CenterHeader = ""
        '.RightHeader = ""
        .LeftFooter = "Archivo: &F" & Chr(10) & "Página &P de &N"
        '.CenterFooter = ""
        .RightFooter = "Hoja: &A" & Chr(10) & "&D - &T"
        .LeftMargin = Application.InchesToPoints(0.590551181102362)
        .RightMargin = Application.InchesToPoints(0.590551181102362)
        .TopMargin = Application.InchesToPoints(0.590551181102362)
        .BottomMargin = Application.InchesToPoints(0.590551181102362)
        .HeaderMargin = Application.InchesToPoints(0.393700787401575)
        .FooterMargin = Application.InchesToPoints(0.393700787401575)
        '.PrintHeadings = False
        '.PrintGridlines = False
        '.PrintComments = xlPrintNoComments
        '.PrintQuality = 600
        .CenterHorizontally = True
        '.CenterVertically = False
        .Orientation = InPageOrientation
        '.Draft = False
        '.PaperSize = xlPaperLetter
        '.FirstPageNumber = xlAutomatic
        '.Order = xlDownThenOver
        '.BlackAndWhite = False
        .Zoom = False
        .FitToPagesWide = InPagesWide
        .FitToPagesTall = InPagesTall
        '.PrintErrors = xlPrintErrorsDisplayed
    End With
    Application.INTERACTIVE = lbBKInteractive
    Application.Visible = lbBKVisible
    Application.ScreenUpdating = lbScreenUpdating
End Sub

Sub ShowAllSheets()
    On Error Resume Next
    BkScreenUpdating = Application.ScreenUpdating: Application.ScreenUpdating = False
    For Each mySheet In Worksheets
        Debug.Print mySheet.Index, mySheet.Name
        mySheet.Visible = xlSheetVisible
    Next
    Application.ScreenUpdating = BkScreenUpdating
End Sub

Sub ToggleSheetTabs()
    ActiveWindow.DisplayWorkbookTabs = Not ActiveWindow.DisplayWorkbookTabs
End Sub

Sub VisibleCellsOnly()
    Selection.SpecialCells(xlCellTypeVisible).Select
End Sub

Sub ShowAllPrecedents()
Dim c As Range
For Each c In Selection
    c.ShowPrecedents
Next
End Sub

Sub ShowAllDependents()
Dim c As Range
For Each c In Selection
    c.ShowDependents
Next
End Sub
\\\--- END OF MODULE ---

[ThisWorkbook] 7 líneas de código.
///--- BEGINNING OF MODULE ---
Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)
    MyLibs.ExportToTxt ThisWorkbook
End Sub

Private Sub Workbook_Open()
    ConfigMacroShortcuts
End Sub
\\\--- END OF MODULE ---

[Sheet1] 0 líneas de código.
///--- BEGINNING OF MODULE ---
\\\--- END OF MODULE ---

[Utils] 22 líneas de código.
///--- BEGINNING OF MODULE ---
'==================================================================================
'Ayudantes para diversas funciones.
'==================================================================================
'
Global Const PRINT_DEBUG_MSGS = True
'
'

Function AssertActiveWindow()
    AssertActiveWindow = Not ActiveWindow Is Nothing
End Function

'==================================================================================
'Helper para debugear
'==================================================================================
Function PrintDebug(StrToPrint)
    If PRINT_DEBUG_MSGS Then Debug.Print StrToPrint
End Function

Sub tst()
    stSelection = foWBChooser.GetSelection()
End Sub
\\\--- END OF MODULE ---

[UI] 3 líneas de código.
///--- BEGINNING OF MODULE ---
'==================================================================================
'Funciones que ayudan a la presentación
'==================================================================================
\\\--- END OF MODULE ---

[foWBChooser] 48 líneas de código.
///--- BEGINNING OF MODULE ---
'==================================================================================
'Forma que va a listar los libros abiertos.
'==================================================================================

Private stSeleccion

Private Sub cobuCancel_Click()
    Me.Hide
End Sub

Private Sub cobuOk_Click()
    ProcesaSeleccion
End Sub

Private Sub liboFiles_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    ProcesaSeleccion
End Sub

Private Sub ProcesaSeleccion()
    stSeleccion = liboFiles.value
    Me.Hide
End Sub

Private Sub MyInit()
    stSeleccion = ""
    EnumWorkbooks
End Sub

'Enumera los libros abiertos. Exluimos los que se abren automático.
Private Function EnumWorkbooks()
    Const AUTO_PATH_SUBSTR = "XLSTART"
    
    Dim oWB As Workbook
    
    For Each oWB In Workbooks
        If InStr(1, UCase(oWB.path), AUTO_PATH_SUBSTR) = 0 Then
            liboFiles.AddItem oWB.Name
        End If
    Next
End Function

Public Function GetSelection()
    MyInit
    
    Me.Show
    GetSelection = stSeleccion
    Unload Me
End Function
\\\--- END OF MODULE ---

[VC_COT] 149 líneas de código.
///--- BEGINNING OF MODULE ---
'==================================================================================
'Importar y exportar los módulos comunes de VBA para los libros que sean cotizadores.
'Util para control de versiones de los módulos.
'==================================================================================

Const VC_COMMON_PATH = "E:\Work\Cotizadores\Módulos"
Const VC_IMPORT_PATH = VC_COMMON_PATH & "\DEV" 'Aquí se depositan los módulos
Const VC_EXPORT_PATH = VC_COMMON_PATH & "\MAIN" 'De aquí se toman los módulos
Const VC_MODULE_PREFIX = "_CODE"
Const VC_FILE_EXTENSION = "BAS"
Const VC_EXPORT_TOKEN = "'#EXPORT#" 'Si esta es la primera línea en los módulos, se procesan.

Dim oFS As New Scripting.FileSystemObject

'==================================================================================
'Importa los módulos VBA de un libro.
'==================================================================================
Function GetModules()
    'Seleccionamos el libro
    stSelection = foWBChooser.GetSelection()
    If stSelection = "" Or IsNull(stSelection) Then Exit Function
    
    Dim oVBComp As VBComponent
    Dim oWB As Workbook
    
    Set oWB = Workbooks(stSelection)
    
    For Each oVBComp In oWB.VBProject.VBComponents
        'Verificamos que la primera línea contenga la marca y que no sea un documento.
        If UCase(Trim(oVBComp.CodeModule.Lines(1, 1))) = VC_EXPORT_TOKEN _
        And oVBComp.Type <> vbext_ct_Document Then
            sname = GenModuleFilename(oVBComp.Name)
            sFullName = VC_IMPORT_PATH & "\" & sname & ""
            
            PrintDebug "Exportando módulo " & oVBComp.Name & " as " & sFullName
            oVBComp.Export sFullName
        End If
    Next
End Function

'==================================================================================
'Agrega los módulos a un libro.
'==================================================================================
Function PutModules()
    'Seleccionamos el libro
    stSelection = foWBChooser.GetSelection()
    If stSelection = "" Or IsNull(stSelection) Then Exit Function
    
    Dim oFol As Folder
    Dim oFil As File
    Dim oWB As Workbook
    
    Set oWB = Workbooks(stSelection)
    
    Set oFol = oFS.GetFolder(VC_EXPORT_PATH)
    For Each oFil In oFol.Files
        'Filtramos los archivos con la extensión que nos interesa
        If UCase(oFS.GetExtensionName(oFil.Name)) = VC_FILE_EXTENSION Then
            ModName = GetModuleNameFromFile(oFil.Name)
            'Si ya existe, lo reemplazamos..
            If ModuleExists(oWB.VBProject, ModName) Then oWB.VBProject.VBComponents.Remove oWB.VBProject.VBComponents(ModName)
            oWB.VBProject.VBComponents.Import oFil.path
        End If
    Next
    
End Function

'==================================================================================
'Agrega los módulos a un libro, pero deja seleccionar cuales.
'==================================================================================
Function PutModulesFilter()
    'Seleccionamos el libro
    stSelection = foWBChooser.GetSelection()
    If stSelection = "" Or IsNull(stSelection) Then Exit Function
    
    Dim oFol As Folder
    Dim oFil As File
    Dim oWB As Workbook
    
    Set oWB = Workbooks(stSelection)
    
    Set oFol = oFS.GetFolder(VC_EXPORT_PATH)
    
    '----------------------------------------------------------------------------------
    'Primero vamos a contruir un arreglo con los nombres de los archivos que cumplan con el criterio.
    Dim ArChivos()
    ArChivos = Array()
    For Each oFil In oFol.Files
        'Filtramos los archivos con la extensión que nos interesa
        If UCase(oFS.GetExtensionName(oFil.Name)) = VC_FILE_EXTENSION Then
            'Los agregamos al arreglo
            nNewIndex = UBound(ArChivos) + 1
            ReDim Preserve ArChivos(nNewIndex)
            ArChivos(nNewIndex) = oFil.Name
        End If
    Next
    'En caso de que no haya archivos con el criterio. Suspendemos proceso.
    If UBound(ArChivos) < 0 Then MsgBox "Ningún módulo para procesar." & vbCrLf & "Proceso terminado.", vbOKOnly + vbInformation: Exit Function

    '----------------------------------------------------------------------------------
    'Después vamos a filtrar aquellos módulos que nos interesen.
    ArChivos = foOptionChooser.ChooseFrom(ArChivos)

    'Si no se seleccionó ninguno:
    'If UBound(ArChivos) < 0 Then MsgBox "Ningún módulo para procesar." & vbCrLf & "Proceso terminado.", vbOKOnly + vbInformation: Exit Function

    '----------------------------------------------------------------------------------
    'Por último se importan los módulos seleccionados.
    For Each ActualFileName In ArChivos
        ModName = GetModuleNameFromFile(CStr(ActualFileName))
        sFullName = VC_EXPORT_PATH & "\" & ActualFileName
        PrintDebug ModName & ", " & sFullName
        'Si ya existe, lo reemplazamos..
        If ModuleExists(oWB.VBProject, ModName) Then oWB.VBProject.VBComponents.Remove oWB.VBProject.VBComponents(ModName)
        oWB.VBProject.VBComponents.Import sFullName
    Next
    
    MsgBox "Proceso terminado.", vbOKOnly + vbInformation
    
End Function

'==================================================================================
'Construye el nombre del archivo que se va a usar para exportar/importar
'==================================================================================
Function GenModuleFilename(ModuleName$)
    GenModuleFilename = ModuleName & VC_MODULE_PREFIX & "." & VC_FILE_EXTENSION
End Function

'==================================================================================
'Extrae el nombre del módulo de un archivo (sin path)
'==================================================================================
Function GetModuleNameFromFile(FileName$)
    sname = FileName
    nprefixpos = InStr(1, sname, VC_MODULE_PREFIX)
    GetModuleNameFromFile = Left(sname, nprefixpos - 1)
End Function

'==================================================================================
'Indica si un módulo ya existe en el proyecto (Por nombre únicamente)
'==================================================================================
Function ModuleExists(oProject As VBProject, ModName)
    Dim oVBComp As VBComponent
    Dim bResult
    
    For Each oVBComp In oProject.VBComponents
        If UCase(oVBComp.Name) = UCase(ModName) Then bResult = True: Exit For
    Next
    ModuleExists = bResult
End Function
\\\--- END OF MODULE ---

[foOptionChooser] 76 líneas de código.
///--- BEGINNING OF MODULE ---
'==================================================================================
'Forma que permite seleccionar una o más opciones.
'Espera un arreglo de opciones, y regresa un arreglo con las opciones seleccionadas.
'Por default selecciona todas las opciones proporcionadas (Transparente)
'==================================================================================
' Interfaz pública:
' Public Function ChooseFrom(arOptions)
'==================================================================================

Private arResultado
Private arSource

Private Sub cobuCancel_Click()
    Me.Hide
End Sub

Private Sub cobuOk_Click()
    ProcesaSeleccion
End Sub

Private Sub cobuSelectAll_Click()
    SelectAll
End Sub

Private Sub cobuSelectNone_Click()
    SelectNone
End Sub

Private Sub SelectAll()
    Debug.Print "SelectAll()"
    For nc% = 0 To liboOptions.ListCount - 1
        liboOptions.Selected(nc) = True
    Next
End Sub

Private Sub SelectNone()
    For nc% = 0 To liboOptions.ListCount - 1
        liboOptions.Selected(nc) = False
    Next
End Sub

Private Sub MyInit()
    arResultado = Array()
    liboOptions.Clear
    For Each elem In arSource
        liboOptions.AddItem (elem)
        liboOptions.Selected(liboOptions.ListCount - 1) = True 'Vamos seleccionando conforme vamos añadiendo.
    Next
End Sub

Private Function ProcesaSeleccion()
    For nc% = 0 To liboOptions.ListCount - 1
        If liboOptions.Selected(nc) Then
            nNewIndex = UBound(arResultado) + 1
            ReDim Preserve arResultado(nNewIndex)
            arResultado(nNewIndex) = liboOptions.List(nc)
        End If
    Next
    Me.Hide
End Function

Public Function ChooseFrom(arOptions)
    If Not IsArray(arOptions) Then arOptions = Array(arOptions) 'Para que no truene y sólo presente la opción.
    arSource = arOptions
    
    MyInit 'Limpia la lista de opciones y la llena con los datos proporcionados.
    
    Me.Show
    If IsEmpty(arResultado) Then 'Por si se cierra la ventana con el cuadro de control en lugar de con los botones
        ChooseFrom = Array() 'Arreglo vacío, equivalente a nada seleccionado.
    Else
        ChooseFrom = arResultado
    End If
    Unload Me
End Function

\\\--- END OF MODULE ---

[RemoveInternalPasswords] 14 líneas de código.
///--- BEGINNING OF MODULE ---
'Abre el libro AllInternalPasswords.xls que contiene todas las macros y componentes para eliminar las contraseñas internas de libros excel 2003 y anteriores.
Option Explicit

Const BOOK_PATH As String = "..\OtherBooks\allinternalpasswords.xls" 'Ruta relativa hacia el libro.

Sub RemoveInternalPasswords()
    Dim BL As BookLoaderClass: Set BL = New BookLoaderClass
    BL.ErrNum = 0: BL.OpenLibBook ("InternalPasswordsRemover.xls")
    If BL.ErrNum <> 0 Then Err.Raise BL.ErrNum, , BL.ErrDesc

    MsgBox "Se removerán las contraseñas de protección del libro y las hojas, si existen." & vbNewLine & vbNewLine & "Por favor espere. " & vbNewLine & "El proceso puede tardar algunos minutos.", vbOKOnly, "Remove Internal Passwords"
    Application.Run BL.GetFunctionName
    MsgBox "Proceso terminado.", vbOKOnly, "Remove Internal Passwords"
End Sub
\\\--- END OF MODULE ---

[ReplaceByRange] 41 líneas de código.
///--- BEGINNING OF MODULE ---
'---------------------------------------------------------------------------------------
' Module    : ReplaceByRange
' Author    : +
' Date      : 1/08/2012
' Purpose   : Implementa una función para realizar varios Search & Replace dentro de una hoja.
'             Se seleccionan tres áreas. Las primeras dos deben de ser del mismo tamaño.
'             La primer área contiene los valores a buscar.
'             La segunda área contiene los valores para reemplazar.
'             La tercer área es en donde se realizan los search & replace.
'
'             La función principal es ReplaceByRange()
'---------------------------------------------------------------------------------------

Option Explicit

Sub ReplaceByRange()
    If Selection.Areas.Count <> 3 Then
        MsgBox "Deben de seleccionarse 3 areas.", vbOKOnly + vbExclamation
        Exit Sub
    End If
    
    If Selection.Areas(1).Cells.Count <> Selection.Areas(2).Cells.Count Then
        MsgBox "El área 1 y 2 deben de tener el mismo número de celdas.", vbOKOnly + vbExclamation
        Exit Sub
    End If
    
    ReplaceByRangeWorker Selection.Areas(1), _
                         Selection.Areas(2), _
                         Selection.Areas(3)
End Sub

Sub ReplaceByRangeWorker(FindWhat As Range, ReplaceWith As Range, SearchWhere As Range)
    Dim i As Long
    Dim Que As String, ConQue As String
    
    For i = 1 To FindWhat.Cells.Count
        Que = FindWhat.Cells(i).value
        ConQue = ReplaceWith.Cells(i).value
        SearchWhere.Replace Que, ConQue
    Next i
End Sub
\\\--- END OF MODULE ---

[MyLibs] 44 líneas de código.
///--- BEGINNING OF MODULE ---
'---------------------------------------------------------------------------------------
' Module    : MyLibs
' Author    : +
' Date      : 04/06/2013
' Purpose   : Módulo que va a servir de pegamento entre este archivo de Macros Personales y los diferentes archivos con librerías.
'---------------------------------------------------------------------------------------

Option Explicit

'====================================================================================================
' Uso de ExportToTxt
'====================================================================================================
'En los libros que se quiera exportar a texto automáticamente al grabar, agregar el siguiente estatuto en su evento Workbook.BeforeSave:
'Application.Run "Personal.xlsb!MyLibs.ExportToTxt", ThisWorkbook
'
'Para exportar en demanda, ejecutar la rutina ExportToTxtConConfirmacion, y se exportará el libro activo.
'====================================================================================================

Public Sub ExportToTxt(book As Workbook, Optional visual As Boolean = False)
On Error GoTo ExportToTxt_Error
    Dim RH As New RunHelperClass
    RH.SetCalculation (xlCalculationManual)
    Dim BL 'Para tener la referencia a la instancia de BookLoader y cuando se destruya, cierre el libro.
    RH.ErrNum = 0: Set BL = RH.OpenLibBook("ExportToTxt.xls")
    If RH.ErrNum <> 0 Then Err.Raise RH.ErrNum, , RH.ErrDesc
    
    Application.Run BL.GetFunctionName, book, visual
On Error GoTo 0
Exit Sub
ExportToTxt_Error:
    Debug.Print "*** Ocurrió un error en la rutina Personal!MyLibs.CorreRutina"
    Debug.Print "*** Error No: " & Err.Number & ". " & Err.Description
End Sub

Public Sub ExportToTxtConConfirmacion()
    ExportToTxt ActiveWorkbook, True
End Sub

'----------------------------------------------------------------------------------------------------
'Purpose: Regresa una nueva instancia de RunHelperClass.
'----------------------------------------------------------------------------------------------------
Public Function GetRunHelper() As RunHelperClass
    Set GetRunHelper = New RunHelperClass
End Function
\\\--- END OF MODULE ---

[BookLoaderClass] 99 líneas de código.
///--- BEGINNING OF MODULE ---
Option Explicit

Private CurrentActiveBook As Workbook
Private SummonedBook As Workbook
Private LeaveBookOpenOnTerminate As Boolean

Private FSO As New Scripting.FileSystemObject

Private Const DEFAULT_LEAVE_BOOK_OPEN As Boolean = False

Public ErrNum, ErrDesc 'Auxiliares para detalles de error, por si se sigue el modelo de manejo de errores tipo delegado.

'Abre un libro a partir de la ruta completa. Deja activo el libro que lo estaba cuando se llama.
Public Sub OpenBook(bookFilenameFullPath As String)
    SaveCurrentBook

    Dim JustName As String: JustName = FSO.GetFileName(bookFilenameFullPath)
    If BookAlreadyOpen(JustName) Then
        LeaveBookOpenOnTerminate = True
        Set SummonedBook = Workbooks(JustName)
    Else
        Set SummonedBook = Workbooks.Open(bookFilenameFullPath)
    End If
    If SummonedBook Is Nothing Then Err.Raise vbObjectError + 1, , "No se abrió el archivo de librería [" & JustName & "]"
    
    RestoreCurrentBook
End Sub

'Un Lib book es relativo al libro actual. Se le concatena la ruta al directorio de las librerías.
'Como es un método público de una clase, vamos a usar el modelo de manejo de errores de los delegados...
Public Sub OpenLibBook(bookFileName As String)
On Error GoTo DelegateError
    Dim PathCompleta As String
    PathCompleta = FSO.BuildPath(ThisWorkbook.path, LIB_PATH)
    PathCompleta = FSO.BuildPath(PathCompleta, FSO.GetBaseName(bookFileName))
    PathCompleta = FSO.BuildPath(PathCompleta, bookFileName)
    OpenBook (PathCompleta)
DelegateError:
    ErrNum = Err.Number: ErrDesc = Err.Description
End Sub

Private Sub SaveCurrentBook()
    Set CurrentActiveBook = ActiveWorkbook
End Sub

Private Sub RestoreCurrentBook()
    On Error Resume Next
    CurrentActiveBook.Activate 'Puede fallar si el libro está oculto (en la ventana de Excel)
    On Error GoTo 0
End Sub

Private Sub CloseBook()
    If Not SummonedBook Is Nothing Then
        'Debug.Print "[BookLoaderClas] Cerrando libro de librería [" & SummonedBook.Name & "]"
        SummonedBook.Close False
    End If
    Set SummonedBook = Nothing
End Sub

Private Sub Class_Initialize()
    LeaveBookOpenOnTerminate = DEFAULT_LEAVE_BOOK_OPEN
End Sub

'Cuando la clase se destruye, cierra el libro, y recupera el modo de cálculo
Private Sub Class_Terminate()
    'Debug.Print "BookLoaderClass.Terminate()"
    If Not LeaveBookOpenOnTerminate Then CloseBook
End Sub

'Determina si hay un libro abierto por nombre
Private Function BookAlreadyOpen(bookName As String) As Boolean
On Error GoTo NotOpen
    Dim BookToTest: Set BookToTest = Workbooks(bookName)
    BookAlreadyOpen = True 'No tronó: se encontró el libro.
    Exit Function
NotOpen:
    BookAlreadyOpen = False
End Function

'Las constantes de esta funcion están definidas en el módulo Config.
Public Function GetFunctionName(Optional rutina As String = LIB_MAIN_FUNCTION_NAME) As String
    GetFunctionName = SummonedBook.Name & "!" & LIB_MODULE_NAME & "." & rutina
End Function

'----------------------------------------------------------------------------------------------------
'Purpose: Regresa el objeto principal de la librería.
'----------------------------------------------------------------------------------------------------
Public Function GetLib() As Object
Debug.Print "> Inicio BookLoaderClass.GetLib()"
On Error GoTo Outer_Error

    Set GetLib = Application.Run(GetFunctionName("GetLib"))
On Error GoTo 0
Outer_Error: 'Error Handler v1.1 - 2013-06-19 by +
    If Err.Number <> 0 Then Debug.Print "[" & ThisWorkbook.Name & "!BookLoaderClass.GetLib] " & Err.Number & ". " & Err.Description
    Debug.Print "> Fin BookLoaderClass.GetLib()": Debug.Print
    'Descomentar si esta rutina se va a llamar desde otro módulo/proyecto:
    ErrNum = Err.Number: ErrDesc = Err.Description
End Function
\\\--- END OF MODULE ---

[Config] 67 líneas de código.
///--- BEGINNING OF MODULE ---
'---------------------------------------------------------------------------------------
' File      : Archivo Personal de Macros (APM)
' Author    : +
' Date      : 12/06/2013
' Purpose   : Macros útiles que siempre están disponibles en Excel.
' Version   : v1.8
'---------------------------------------------------------------------------------------

Global Const PRINT_PROC_DELIMITERS As Boolean = False

'Path relativa al libro actual en donde se encuentran los archivos de librerías.
Public Const LIB_PATH As String = "..\MyLibs"

'El nombre del módulo principal en los archivos de librerías.
Public Const LIB_MODULE_NAME As String = "Lib"

'El nombre de la función principal dentro del módulo de librería.
Public Const LIB_MAIN_FUNCTION_NAME As String = "Main"

Private UC As New UtilsClass

'----------------------------------------------------------------------------------------------------
'Purpose: Asigna atajos a las macros según la ubicación del libro, y lo graba.
'----------------------------------------------------------------------------------------------------
Public Sub ConfigMacroShortcuts()
On Error GoTo CMS_Error
    Debug.Print "-----------------------------------------------------------"
    Debug.Print "Archivo Personal de Macros: ConfigMacroShortcuts()"
    Debug.Print "-----------------------------------------------------------"
    Debug.Print "Asignando los shortcuts a las macros."
    
    'Agregamos verificación de libros visibles.
    'Los estatutos de MacroOptions fallan cuando no hay libros visibles.
    If UC.NumVisibleBooks = 0 Then
        Debug.Print "No hay libros visibles. Cancelando."
        Exit Sub
    End If
    
    If UC.IsAutoStartPath(ThisWorkbook.path) Then
        ShortcutsPrd
    Else
        ShortcutsDev
    End If
    
    'Desactivamos los eventos para que no se ejecute el event handler del libro.
    Debug.Print "Listo. Grabando..."
    Dim BkEnableEvents
    BkEnableEvents = UC.SetAppEnableEvents(False)
    ThisWorkbook.Save
    Application.EnableEvents = BkEnableEvents
    
    Debug.Print "Terminada la inicialización de los shortcuts de las macros."
    Debug.Print "-----------------------------------------------------------"
Exit Sub
CMS_Error:
    Debug.Print "Error en ConfigMacroShortcuts: " & Err.Number & " " & Err.Description
End Sub

Private Sub ShortcutsPrd()
    Debug.Print "> Usando los shortcuts de Prd."
    Application.MacroOptions Macro:=ThisWorkbook.Name & "!ExportToTxtConConfirmacion", ShortcutKey:="t"
End Sub

Private Sub ShortcutsDev()
    Debug.Print "> Usando los shortcuts de Dev."
    Application.MacroOptions Macro:=ThisWorkbook.Name & "!ExportToTxtConConfirmacion", ShortcutKey:="r"
End Sub
\\\--- END OF MODULE ---

[UtilsClass] 235 líneas de código.
///--- BEGINNING OF MODULE ---
' Module Header v1.0 - 2013-06-28.
'---------------------------------------------------------------------------------------
' Module    : UtilsClass
' Author    : +
' Date      : 17/06/2013
' Purpose   : Clase con métodos ayudantes y utilitarios.
'---------------------------------------------------------------------------------------
Option Explicit

Public ErrNum, ErrDesc
'----------------------------------------------------------------------------------------------------

'Para construir la ruta al folder de Auto Start:
Private Const AUTO_START_PATH_PREFIX As String = "AppData" 'Variable de entorno a expandir.
Private Const AUTO_START_PATH_SUFFIX As String = "Microsoft\Excel\XLSTART"

'----------------------------------------------------------------------------------------------------
'Purpose: Regresa un nuevo objeto FileSystemObject
'----------------------------------------------------------------------------------------------------
Public Function GetFSO() As FileSystemObject
    Set GetFSO = New FileSystemObject
End Function

'----------------------------------------------------------------------------------------------------
'Purpose: Obtiene la ruta de Auto Start, expandiendo la variable de entorno correspondiente.
'----------------------------------------------------------------------------------------------------
Public Function GetAutoStartPath() As String
    GetAutoStartPath = GetFSO().BuildPath(Environ(AUTO_START_PATH_PREFIX), AUTO_START_PATH_SUFFIX)
End Function

'----------------------------------------------------------------------------------------------------
'Purpose: Compara una ruta proporcionada y regresa verdadero si es la ruta de Auto Start de Excel.
'----------------------------------------------------------------------------------------------------
Public Function IsAutoStartPath(path As String) As Boolean
    If UCase(path) = UCase(GetAutoStartPath()) Then IsAutoStartPath = True
End Function

'----------------------------------------------------------------------------------------------------
'Purpose: Asigna Application.EnableEvents y regresa el valor que tenía para propósitos de almacenamiento.
'----------------------------------------------------------------------------------------------------
Public Function SetAppEnableEvents(value As Boolean) As Boolean
    SetAppEnableEvents = Application.EnableEvents
    Application.EnableEvents = value
End Function

'----------------------------------------------------------------------------------------------------
'Purpose: Regresa el número de ventanas de libro visibles en Excel. (Algunas funciones truenan si no hay libros visibles)
'----------------------------------------------------------------------------------------------------
Public Function NumVisibleBooks() As Integer
    NumVisibleBooks = 0
    Dim wnd As Window
    For Each wnd In Application.Windows
        If wnd.Visible Then NumVisibleBooks = NumVisibleBooks + 1
    Next
End Function

'----------------------------------------------------------------------------------------------------
'Purpose: Recibe un nombre de macro y una colección de parámetros para usarse con Application.Run().
'Soporta hasta 5 parámetros.
'----------------------------------------------------------------------------------------------------
Sub CallFunctWithVarParams(macroName As String, args As Collection)
    Dim NumParams As Integer: NumParams = args.Count
    Select Case NumParams
    Case 0
        Application.Run macroName
    Case 1
        Application.Run macroName, args(1)
    Case 2
        Application.Run macroName, args(1), args(2)
    Case 3
        Application.Run macroName, args(1), args(2), args(3)
    Case 4
        Application.Run macroName, args(1), args(2), args(3), args(4)
    Case 5
        Application.Run macroName, args(1), args(2), args(3), args(4), args(5)
    End Select
End Sub

'----------------------------------------------------------------------------------------------------
'Purpose: Recibe un objeto, el nombre de un método y una colección de parámetros para usarse con CallByName().
'Soporta hasta 5 parámetros.
'----------------------------------------------------------------------------------------------------
Sub CallMethodWithVarParams(instance As Object, procName As String, args As Collection, Optional callType As VbCallType = VbCallType.VbMethod)
    Dim NumParams As Integer: NumParams = args.Count
    Select Case NumParams
    Case 0
        CallByName instance, procName, callType
    Case 1
        CallByName instance, procName, callType, args(1)
    Case 2
        CallByName instance, procName, callType, args(1), args(2)
    Case 3
        CallByName instance, procName, callType, args(1), args(2), args(3)
    Case 4
        CallByName instance, procName, callType, args(1), args(2), args(3), args(4)
    Case 5
        CallByName instance, procName, callType, args(1), args(2), args(3), args(4), args(5)
    End Select
End Sub

'----------------------------------------------------------------------------------------------------
'Purpose:Regresa una colección con los elementos de une arreglo.
'----------------------------------------------------------------------------------------------------
Function ArrToCol(rg) As Collection
If PRINT_PROC_DELIMITERS Then Debug.Print "> Inicio UtilsClass.ArrToCol()"
On Error GoTo Outer_Error
'----------------------------------------------------------------------------------------------------
    Dim Res As New Collection
    Dim item
    For Each item In rg
        Res.Add (item)
    Next
    Set ArrToCol = Res
'----------------------------------------------------------------------------------------------------
On Error GoTo 0
Outer_Error: 'Error Handler v1.2 - 2013-06-28. Requires Module Header v1.0
    If Err.Number <> 0 Then Err.Description = Err.Description & vbCrLf & " - [" & ThisWorkbook.Name & "!UtilsClass.ArrToCol()]": Debug.Print "[Error] " & Err.Number & ". " & Err.Description
    If PRINT_PROC_DELIMITERS Then Debug.Print "> Fin UtilsClass.ArrToCol()" & vbCrLf
    ErrNum = Err.Number: ErrDesc = Err.Description
    'Err.Raise Err.Number, , Err.Description 'Descomentar si se quiere que el error se marque aquí en lugar de burbujear.
End Function

'----------------------------------------------------------------------------------------------------
'Purpose: Regresa un arreglo con los elementos de una colección.
'----------------------------------------------------------------------------------------------------
Function ColToArr(c As Collection) As Variant()
If PRINT_PROC_DELIMITERS Then Debug.Print "> Inicio UtilsClass.ColToArr()"
On Error GoTo Outer_Error
'----------------------------------------------------------------------------------------------------
    Dim a() As Variant: ReDim a(0 To c.Count - 1)
    Dim i As Integer
    For i = 1 To c.Count
        a(i - 1) = c.item(i)
    Next
    ColToArr = a
'----------------------------------------------------------------------------------------------------
On Error GoTo 0
Outer_Error: 'Error Handler v1.2 - 2013-06-28. Requires Module Header v1.0
    If Err.Number <> 0 Then Err.Description = Err.Description & vbCrLf & " - [" & ThisWorkbook.Name & "!UtilsClass.ColToArr()]": Debug.Print "[Error] " & Err.Number & ". " & Err.Description
    If PRINT_PROC_DELIMITERS Then Debug.Print "> Fin UtilsClass.ColToArr()" & vbCrLf
    ErrNum = Err.Number: ErrDesc = Err.Description
    'Err.Raise Err.Number, , Err.Description 'Descomentar si se quiere que el error se marque aquí en lugar de burbujear.
End Function

'----------------------------------------------------------------------------------------------------
'Purpose:Regresa una colección nueva con los elementos de otra colección.
'----------------------------------------------------------------------------------------------------
Function CopyCollectionItems(colToCopy As Collection) As Collection
If PRINT_PROC_DELIMITERS Then Debug.Print "> Inicio UtilsClass.CopyCollectionItems()"
On Error GoTo Outer_Error
'----------------------------------------------------------------------------------------------------
    Dim Res As New Collection
    Dim item As Variant
    For Each item In colToCopy
        Res.Add (item)
    Next
    Set CopyCollectionItems = Res
'----------------------------------------------------------------------------------------------------
On Error GoTo 0
Outer_Error: 'Error Handler v1.2 - 2013-06-28. Requires Module Header v1.0
    If Err.Number <> 0 Then Err.Description = Err.Description & vbCrLf & " - [" & ThisWorkbook.Name & "!UtilsClass.CopyCollectionItems()]": Debug.Print "[Error] " & Err.Number & ". " & Err.Description
    If PRINT_PROC_DELIMITERS Then Debug.Print "> Fin UtilsClass.CopyCollectionItems()" & vbCrLf
    ErrNum = Err.Number: ErrDesc = Err.Description
    'Err.Raise Err.Number, , Err.Description 'Descomentar si se quiere que el error se marque aquí en lugar de burbujear.
End Function

'----------------------------------------------------------------------------------------------------
'Purpose: Agrega un elemento al inicio de una colección.
'----------------------------------------------------------------------------------------------------
Function CollectionAddFirst(colToAdd As Collection, item As Variant)
If PRINT_PROC_DELIMITERS Then Debug.Print "> Inicio UtilsClass.CollectionAddFirst()"
On Error GoTo Outer_Error
'----------------------------------------------------------------------------------------------------
    If colToAdd.Count <> 0 Then
        colToAdd.Add item, , 1
    Else
        colToAdd.Add item
    End If
'----------------------------------------------------------------------------------------------------
On Error GoTo 0
Outer_Error: 'Error Handler v1.2 - 2013-06-28. Requires Module Header v1.0
    If Err.Number <> 0 Then Err.Description = Err.Description & vbCrLf & " - [" & ThisWorkbook.Name & "!UtilsClass.CollectionAddFirst()]": Debug.Print "[Error] " & Err.Number & ". " & Err.Description
    If PRINT_PROC_DELIMITERS Then Debug.Print "> Fin UtilsClass.CollectionAddFirst()" & vbCrLf
    ErrNum = Err.Number: ErrDesc = Err.Description
    'Err.Raise Err.Number, , Err.Description 'Descomentar si se quiere que el error se marque aquí en lugar de burbujear.
End Function

'----------------------------------------------------------------------------------------------------
'Purpose: Regresa un string con formato de tiempo para representar un intervalo: 05:45 min.
'----------------------------------------------------------------------------------------------------
Function FormatEllapsedTime(secondsEllapsed As Long) As String
    Dim Time As String, Units As String
    Time = GetEllapsedTime(secondsEllapsed)
    Units = GetEllapsedUnits(secondsEllapsed)
    FormatEllapsedTime = Time & " " & Units
End Function

Function GetEllapsedTime(secondsEllapsed As Long) As String
    Dim SECS_IN_MINUTE As Integer: SECS_IN_MINUTE = 60
    Dim Res As String
    If secondsEllapsed / SECS_IN_MINUTE > 1 Then
        Dim Minutes, SecondsLeft
        Minutes = Int(secondsEllapsed / SECS_IN_MINUTE)
        SecondsLeft = secondsEllapsed - (Minutes * SECS_IN_MINUTE)
        Res = PadL(FormatNumber(Minutes, 0), 2, "0") & ":" & GetEllapsedTime(CLng(SecondsLeft))
    Else
        Res = PadL(FormatNumber(secondsEllapsed, 0), 2, "0")
    End If
    GetEllapsedTime = Res
End Function

Function GetEllapsedUnits(secondsEllapsed As Long) As String
    Dim SECS_IN_MINUTE As Integer: SECS_IN_MINUTE = 60
    Dim Res As String, Units As String
    If secondsEllapsed / SECS_IN_MINUTE > 1 Then
        Res = "min."
    Else
        Res = "sec."
    End If
    GetEllapsedUnits = Res
End Function

'----------------------------------------------------------------------------------------------------
'Purpose:Agrega caracteres a la izquierda de un string.
'----------------------------------------------------------------------------------------------------
Function PadL(str As String, leng As Integer, Optional char As String = " ") As String
    Dim Res As String
    If Len(str) < leng Then
        Res = String(leng - Len(str), char) & str
    Else
        Res = str
    End If
    PadL = Res
End Function

\\\--- END OF MODULE ---

[RunHelperClass] 87 líneas de código.
///--- BEGINNING OF MODULE ---
'---------------------------------------------------------------------------------------
' Module    : RunHelperClass
' Author    : +
' Date      : 17/06/2013
' Purpose   : Clase que va a servir como apoyo a los "servicios" que provee el APM.
'---------------------------------------------------------------------------------------

Option Explicit

Private BackupCalculationMode As XlCalculation 'Para guardar el modo de cálculo.

Private Utils As New UtilsClass

Private BookLibrariesCollection As New Collection

Public ErrNum, ErrDesc 'Auxiliares para detalles de error, por si se sigue el modelo de manejo de errores tipo delegado.

Public Function GetUtils() As UtilsClass
    Set GetUtils = Utils 'Recicla la misma instancia...
End Function

'Asigna el módo de cálculo, y guarda el actual, para poder recuperarlo posteriormente.
Public Sub SetCalculation(calcMode As XlCalculation)
    On Error Resume Next 'Estos dos estatutos pueden fallar si todos los libros abiertos en excel están ocultos sin ventana visible.
    BackupCalculationMode = Application.Calculation
    Application.Calculation = calcMode
End Sub

Private Sub RestoreCalculation()
    On Error Resume Next 'Puede fallar si no hay ventanas de libros en Excel. (O si falló en SetCalculation())
    Application.Calculation = BackupCalculationMode
    On Error GoTo 0
End Sub

Private Sub Class_Initialize()
Debug.Print "[RunHelperClass] Iniciando."
End Sub

Private Sub Class_Terminate()
    'Debug.Print "RunHelperClass.Terminate()"
    If BackupCalculationMode <> 0 Then RestoreCalculation
    Set BookLibrariesCollection = Nothing
    Debug.Print "[RunHelperClass] Librerías liberadas."
End Sub

Public Function OpenLibBook(bookFileName As String) As BookLoaderClass
On Error GoTo DelegateError
    Dim BL As BookLoaderClass: Set BL = New BookLoaderClass
    BL.ErrNum = 0: BL.OpenLibBook (bookFileName)
    If BL.ErrNum <> 0 Then Err.Raise BL.ErrNum, , BL.ErrDesc
    
    Set OpenLibBook = BL
DelegateError:
    ErrNum = Err.Number: ErrDesc = Err.Description
End Function

'----------------------------------------------------------------------------------------------------
'Purpose:Abre un libro de librería, obtiene la clase, la inicializa y la regresa.
'----------------------------------------------------------------------------------------------------
Public Function GetLibClass(bookFileName As String) As Object
Debug.Print "> Inicio RunHelperClass.GetLibClass()"
On Error GoTo Outer_Error

    ErrNum = 0: Dim BL: Set BL = OpenLibBook(bookFileName)
    If ErrNum <> 0 Then Err.Raise ErrNum, , ErrDesc
    
    BL.ErrNum = 0: Dim Lib: Set Lib = BL.GetLib()
    If BL.ErrNum <> 0 Then Err.Raise BL.ErrNum, , BL.ErrDesc
    
    'Vamos a agregar BookLoaderClass a la colección
    On Error Resume Next
    BookLibrariesCollection.Add BL, bookFileName
    On Error GoTo Outer_Error
    
    Set Lib = Lib.Init()
    Set GetLibClass = Lib
On Error GoTo 0
Outer_Error: 'Error Handler v1.1 - 2013-06-19 by +
    If Err.Number <> 0 Then Debug.Print "[" & ThisWorkbook.Name & "!RunHelperClass.GetLibClass] " & Err.Number & ". " & Err.Description
    Debug.Print "> Fin RunHelperClass.GetLibClass()": Debug.Print
    'Descomentar si esta rutina se va a llamar desde otro módulo/proyecto:
    ErrNum = Err.Number: ErrDesc = Err.Description
End Function

Public Function GetLogger() As LoggerClass
    Set GetLogger = New LoggerClass
End Function
\\\--- END OF MODULE ---

[LoggerClass] 73 líneas de código.
///--- BEGINNING OF MODULE ---
' Module Header v1.0 - 2013-06-28.
'---------------------------------------------------------------------------------------
' Module    : LoggerClass
' Author    : +
' Date      : 01/07/2013
' Purpose   : Escribe líneas a un archivo.
'---------------------------------------------------------------------------------------
Option Explicit

Public ErrNum, ErrDesc
'----------------------------------------------------------------------------------------------------

Private RH As Object
Private Utils As Object
Private FSO As Object
Private Stream As Object

'----------------------------------------------------------------------------------------------------
'Purpose:Inicializa una nueva instancia de un stream. Sobreescribe el archivo si existe.
'----------------------------------------------------------------------------------------------------
Public Sub CreateNewStream(FileName As String)
If PRINT_PROC_DELIMITERS Then Debug.Print "> Inicio LoggerClass.CreateNewStream()"
On Error GoTo Outer_Error
'----------------------------------------------------------------------------------------------------
    Set RH = New RunHelperClass
    Set Utils = RH.GetUtils()
    Set FSO = Utils.GetFSO()
    Set Stream = FSO.CreateTextFile(FileName, True, False)
'----------------------------------------------------------------------------------------------------
On Error GoTo 0
Outer_Error: 'Error Handler v1.2 - 2013-06-28. Requires Module Header v1.0
    If Err.Number <> 0 Then Err.Description = Err.Description & vbCrLf & " - [" & ThisWorkbook.Name & "!LoggerClass.CreateNewStream()]": Debug.Print "[Error] " & Err.Number & ". " & Err.Description
    If PRINT_PROC_DELIMITERS Then Debug.Print "> Fin LoggerClass.CreateNewStream()" & vbCrLf
    ErrNum = Err.Number: ErrDesc = Err.Description
    'Err.Raise Err.Number, , Err.Description 'Descomentar si se quiere que el error se marque aquí en lugar de burbujear.
End Sub

'----------------------------------------------------------------------------------------------------
'Purpose:Escribe una linea en el Stream.
'----------------------------------------------------------------------------------------------------
Public Sub Log(Optional Mensaje As String)
If PRINT_PROC_DELIMITERS Then Debug.Print "> Inicio LoggerClass.Log()"
On Error GoTo Outer_Error
'----------------------------------------------------------------------------------------------------
    'Debug.Print Mensaje
    Stream.WriteLine (Mensaje)
'----------------------------------------------------------------------------------------------------
On Error GoTo 0
Outer_Error: 'Error Handler v1.2 - 2013-06-28. Requires Module Header v1.0
    If Err.Number <> 0 Then Err.Description = Err.Description & vbCrLf & " - [" & ThisWorkbook.Name & "!LoggerClass.Log()]": Debug.Print "[Error] " & Err.Number & ". " & Err.Description
    If PRINT_PROC_DELIMITERS Then Debug.Print "> Fin LoggerClass.Log()" & vbCrLf
    ErrNum = Err.Number: ErrDesc = Err.Description
    'Err.Raise Err.Number, , Err.Description 'Descomentar si se quiere que el error se marque aquí en lugar de burbujear.
End Sub

'----------------------------------------------------------------------------------------------------
'Purpose: Regresa verdadero si al intentar accesar el Stream, marca error. (Se asume que está cerrada)
'----------------------------------------------------------------------------------------------------
Public Function StreamClosed() As Boolean
    On Error GoTo IsClosed
    StreamClosed = Stream.AtEndOfLine
    StreamClosed = False 'No marcó error, el Stream no está cerrado.
    Exit Function
IsClosed:
    StreamClosed = True
End Function

'----------------------------------------------------------------------------------------------------
'Purpose: Cierra el Stream. Múltiples llamadas a Stream.Close no causan error.
'----------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
    If Not Stream Is Nothing Then Stream.Close
End Sub
\\\--- END OF MODULE ---


** Fin del proceso de exportación. **
Lib_ExportToTxt [ExportToTxt.xls] POST v2.11.1 [Con Cambios de APM]
